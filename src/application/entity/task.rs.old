use serde::{Deserialize, Serialize};

// #[derive(Debug, Default, Clone, Serialize, Deserialize)]
// pub enum Task{
//     Habr(HabrTask),
//     FL(FLTask),
//     Kwork(KworkTask),
//     #[default]
//     None
// }
//
// impl Task{
//     pub fn unwrap(&self){
//         match self{
//            Task:: Habr(val) => return val,
//              
//         }
//     }
// }

#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct Task {
    pub title: String,
    pub page: String,
    pub responses: u32,
    pub platform: Platform,
    pub price: Price,
    // Platform specific properties
    // Habr
    // pub timestamp_published: Option<u32>,
    pub published_at: Option<String>,
    pub views: Option<u32>,
    pub tags: Option<Vec<String>>,
    //FL
    pub is_urgent: Option<bool>,
    pub is_vacancy: Option<bool>,
    pub is_pinned: Option<bool>,
    //Kwork
    pub expires_at: Option<String>
    // pub timestamp_expires: Option<u32>,
}

impl Task {
    pub fn get_link(&self) -> String {
        let mut link = match &self.platform {
            Platform::Habr => "https://freelance.habr.com".to_string(),
            Platform::FL => "https://www.fl.ru".to_string(),
            Platform::Kwork => "https://kwork.ru".to_string(),
            _ => "".to_string()
        };
        link.push_str(&self.page);
        link
    }

    pub fn get_platform_string(&self) -> String{
        match &self.platform{
            Platform::Habr => "Habr".to_string(),
            Platform::Kwork => "Kwork".to_string(),
            Platform::FL => "FL".to_string(),
            _ => "".to_string()
        }
    }
}

#[derive(Debug, Default, Clone, Copy, Serialize, Deserialize)]
pub struct Price {
    pub kind: PriceKind,
    pub count: PriceCount
}

#[derive(Debug, Default, Clone, Copy, Serialize, Deserialize)]
pub enum PriceCount {
    Exact(u32),
    Range(u32, u32),
    #[default]
    None
}

#[derive(Debug, Default, Clone, Copy, Serialize, Deserialize)]
pub enum PriceKind {
    #[default]
    Negotiated,
    PerHour(u32),
    PerProject(u32),
}

impl Price {
    pub fn get_price(&self) -> Option<u32> {
        match self.kind {
            PriceKind::Negotiated => None,
            PriceKind::PerHour(val) => Some(val),
            PriceKind::PerProject(val) => Some(val),
        }
    }
    pub fn get_kind(&self) -> String{
        match self.kind {
            PriceKind::Negotiated => "negotiated".to_string(),
            PriceKind::PerHour(_) => "per hour".to_string(),
            PriceKind::PerProject(_) => "per project".to_string()
        }
    }
}

#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub enum Platform {
    Habr(HabrTask),
    FL(FLTask),
    Kwork,
    #[default]
    None
}


#[derive(Debug, Default, Clone, Serialize, Deserialize)]
struct HabrTask{
    published_at: String,
    views: u32,
    tags: Vec<String>
}


#[derive(Debug, Default, Clone, Serialize, Deserialize)]
struct FLTask{
    published_at: String,
    is_urgent: bool,
    is_pinned: bool,
    is_vacancy: bool,
    views: u32,
}


#[derive(Debug, Default, Clone, Serialize, Deserialize)]
struct Kwork{
    expires_at: String
}
